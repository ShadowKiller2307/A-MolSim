// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "schema.hxx"

// doubleList
//

doubleList::
doubleList ()
: ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (this)
{
}

doubleList::
doubleList (size_type n, const ::xml_schema::double_& x)
: ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (n, x, this)
{
}

doubleList::
doubleList (const doubleList& o,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::simple_type (o, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (o, f, this)
{
}

// unsignedIntList
//

unsignedIntList::
unsignedIntList ()
: ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (this)
{
}

unsignedIntList::
unsignedIntList (size_type n, const ::xml_schema::unsigned_int& x)
: ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (n, x, this)
{
}

unsignedIntList::
unsignedIntList (const unsignedIntList& o,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::simple_type (o, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (o, f, this)
{
}

// arrayOfThreeDoubles
// 


// arrayOfThreeUnsignedInts
// 


// Cuboid
// 

const Cuboid::llfc_type& Cuboid::
llfc () const
{
  return this->llfc_.get ();
}

Cuboid::llfc_type& Cuboid::
llfc ()
{
  return this->llfc_.get ();
}

void Cuboid::
llfc (const llfc_type& x)
{
  this->llfc_.set (x);
}

void Cuboid::
llfc (::std::auto_ptr< llfc_type > x)
{
  this->llfc_.set (x);
}

const Cuboid::particlePerDimension_type& Cuboid::
particlePerDimension () const
{
  return this->particlePerDimension_.get ();
}

Cuboid::particlePerDimension_type& Cuboid::
particlePerDimension ()
{
  return this->particlePerDimension_.get ();
}

void Cuboid::
particlePerDimension (const particlePerDimension_type& x)
{
  this->particlePerDimension_.set (x);
}

void Cuboid::
particlePerDimension (::std::auto_ptr< particlePerDimension_type > x)
{
  this->particlePerDimension_.set (x);
}

const Cuboid::particleVelocity_type& Cuboid::
particleVelocity () const
{
  return this->particleVelocity_.get ();
}

Cuboid::particleVelocity_type& Cuboid::
particleVelocity ()
{
  return this->particleVelocity_.get ();
}

void Cuboid::
particleVelocity (const particleVelocity_type& x)
{
  this->particleVelocity_.set (x);
}

void Cuboid::
particleVelocity (::std::auto_ptr< particleVelocity_type > x)
{
  this->particleVelocity_.set (x);
}

const Cuboid::h_type& Cuboid::
h () const
{
  return this->h_.get ();
}

Cuboid::h_type& Cuboid::
h ()
{
  return this->h_.get ();
}

void Cuboid::
h (const h_type& x)
{
  this->h_.set (x);
}

const Cuboid::mass_type& Cuboid::
mass () const
{
  return this->mass_.get ();
}

Cuboid::mass_type& Cuboid::
mass ()
{
  return this->mass_.get ();
}

void Cuboid::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

const Cuboid::generateNumber_type& Cuboid::
generateNumber () const
{
  return this->generateNumber_.get ();
}

Cuboid::generateNumber_type& Cuboid::
generateNumber ()
{
  return this->generateNumber_.get ();
}

void Cuboid::
generateNumber (const generateNumber_type& x)
{
  this->generateNumber_.set (x);
}


// simulationConfig
// 

const simulationConfig::baseName_type& simulationConfig::
baseName () const
{
  return this->baseName_.get ();
}

simulationConfig::baseName_type& simulationConfig::
baseName ()
{
  return this->baseName_.get ();
}

void simulationConfig::
baseName (const baseName_type& x)
{
  this->baseName_.set (x);
}

void simulationConfig::
baseName (::std::auto_ptr< baseName_type > x)
{
  this->baseName_.set (x);
}

const simulationConfig::writeFrequency_type& simulationConfig::
writeFrequency () const
{
  return this->writeFrequency_.get ();
}

simulationConfig::writeFrequency_type& simulationConfig::
writeFrequency ()
{
  return this->writeFrequency_.get ();
}

void simulationConfig::
writeFrequency (const writeFrequency_type& x)
{
  this->writeFrequency_.set (x);
}

const simulationConfig::t_end_type& simulationConfig::
t_end () const
{
  return this->t_end_.get ();
}

simulationConfig::t_end_type& simulationConfig::
t_end ()
{
  return this->t_end_.get ();
}

void simulationConfig::
t_end (const t_end_type& x)
{
  this->t_end_.set (x);
}

const simulationConfig::delta_t_type& simulationConfig::
delta_t () const
{
  return this->delta_t_.get ();
}

simulationConfig::delta_t_type& simulationConfig::
delta_t ()
{
  return this->delta_t_.get ();
}

void simulationConfig::
delta_t (const delta_t_type& x)
{
  this->delta_t_.set (x);
}

const simulationConfig::logLevel_type& simulationConfig::
logLevel () const
{
  return this->logLevel_.get ();
}

simulationConfig::logLevel_type& simulationConfig::
logLevel ()
{
  return this->logLevel_.get ();
}

void simulationConfig::
logLevel (const logLevel_type& x)
{
  this->logLevel_.set (x);
}

const simulationConfig::inputGenerator_type& simulationConfig::
inputGenerator () const
{
  return this->inputGenerator_.get ();
}

simulationConfig::inputGenerator_type& simulationConfig::
inputGenerator ()
{
  return this->inputGenerator_.get ();
}

void simulationConfig::
inputGenerator (const inputGenerator_type& x)
{
  this->inputGenerator_.set (x);
}

const simulationConfig::inputText_type& simulationConfig::
inputText () const
{
  return this->inputText_.get ();
}

simulationConfig::inputText_type& simulationConfig::
inputText ()
{
  return this->inputText_.get ();
}

void simulationConfig::
inputText (const inputText_type& x)
{
  this->inputText_.set (x);
}

const simulationConfig::inputPicture_type& simulationConfig::
inputPicture () const
{
  return this->inputPicture_.get ();
}

simulationConfig::inputPicture_type& simulationConfig::
inputPicture ()
{
  return this->inputPicture_.get ();
}

void simulationConfig::
inputPicture (const inputPicture_type& x)
{
  this->inputPicture_.set (x);
}

const simulationConfig::inputXML_type& simulationConfig::
inputXML () const
{
  return this->inputXML_.get ();
}

simulationConfig::inputXML_type& simulationConfig::
inputXML ()
{
  return this->inputXML_.get ();
}

void simulationConfig::
inputXML (const inputXML_type& x)
{
  this->inputXML_.set (x);
}

const simulationConfig::Cuboid_sequence& simulationConfig::
Cuboid () const
{
  return this->Cuboid_;
}

simulationConfig::Cuboid_sequence& simulationConfig::
Cuboid ()
{
  return this->Cuboid_;
}

void simulationConfig::
Cuboid (const Cuboid_sequence& s)
{
  this->Cuboid_ = s;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// doubleList
//

doubleList::
doubleList (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::simple_type (e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (e, f, this)
{
}

doubleList::
doubleList (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::simple_type (a, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (a, f, this)
{
}

doubleList::
doubleList (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::simple_type (s, e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, this)
{
}

doubleList* doubleList::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class doubleList (*this, f, c);
}

doubleList::
~doubleList ()
{
}

// unsignedIntList
//

unsignedIntList::
unsignedIntList (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::simple_type (e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (e, f, this)
{
}

unsignedIntList::
unsignedIntList (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::simple_type (a, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (a, f, this)
{
}

unsignedIntList::
unsignedIntList (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::simple_type (s, e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (s, e, f, this)
{
}

unsignedIntList* unsignedIntList::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class unsignedIntList (*this, f, c);
}

unsignedIntList::
~unsignedIntList ()
{
}

// arrayOfThreeDoubles
//

arrayOfThreeDoubles::
arrayOfThreeDoubles ()
: ::doubleList ()
{
}

arrayOfThreeDoubles::
arrayOfThreeDoubles (const ::doubleList& _xsd_doubleList_base)
: ::doubleList (_xsd_doubleList_base)
{
}

arrayOfThreeDoubles::
arrayOfThreeDoubles (const arrayOfThreeDoubles& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::doubleList (x, f, c)
{
}

arrayOfThreeDoubles::
arrayOfThreeDoubles (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::doubleList (e, f, c)
{
}

arrayOfThreeDoubles::
arrayOfThreeDoubles (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::doubleList (a, f, c)
{
}

arrayOfThreeDoubles::
arrayOfThreeDoubles (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::doubleList (s, e, f, c)
{
}

arrayOfThreeDoubles* arrayOfThreeDoubles::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class arrayOfThreeDoubles (*this, f, c);
}

arrayOfThreeDoubles::
~arrayOfThreeDoubles ()
{
}

// arrayOfThreeUnsignedInts
//

arrayOfThreeUnsignedInts::
arrayOfThreeUnsignedInts ()
: ::unsignedIntList ()
{
}

arrayOfThreeUnsignedInts::
arrayOfThreeUnsignedInts (const ::unsignedIntList& _xsd_unsignedIntList_base)
: ::unsignedIntList (_xsd_unsignedIntList_base)
{
}

arrayOfThreeUnsignedInts::
arrayOfThreeUnsignedInts (const arrayOfThreeUnsignedInts& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::unsignedIntList (x, f, c)
{
}

arrayOfThreeUnsignedInts::
arrayOfThreeUnsignedInts (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::unsignedIntList (e, f, c)
{
}

arrayOfThreeUnsignedInts::
arrayOfThreeUnsignedInts (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::unsignedIntList (a, f, c)
{
}

arrayOfThreeUnsignedInts::
arrayOfThreeUnsignedInts (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::unsignedIntList (s, e, f, c)
{
}

arrayOfThreeUnsignedInts* arrayOfThreeUnsignedInts::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class arrayOfThreeUnsignedInts (*this, f, c);
}

arrayOfThreeUnsignedInts::
~arrayOfThreeUnsignedInts ()
{
}

// Cuboid
//

Cuboid::
Cuboid (const llfc_type& llfc,
        const particlePerDimension_type& particlePerDimension,
        const particleVelocity_type& particleVelocity,
        const h_type& h,
        const mass_type& mass,
        const generateNumber_type& generateNumber)
: ::xml_schema::type (),
  llfc_ (llfc, this),
  particlePerDimension_ (particlePerDimension, this),
  particleVelocity_ (particleVelocity, this),
  h_ (h, this),
  mass_ (mass, this),
  generateNumber_ (generateNumber, this)
{
}

Cuboid::
Cuboid (const Cuboid& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  llfc_ (x.llfc_, f, this),
  particlePerDimension_ (x.particlePerDimension_, f, this),
  particleVelocity_ (x.particleVelocity_, f, this),
  h_ (x.h_, f, this),
  mass_ (x.mass_, f, this),
  generateNumber_ (x.generateNumber_, f, this)
{
}

Cuboid::
Cuboid (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  llfc_ (this),
  particlePerDimension_ (this),
  particleVelocity_ (this),
  h_ (this),
  mass_ (this),
  generateNumber_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Cuboid::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // llfc
    //
    if (n.name () == "llfc" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< llfc_type > r (
        llfc_traits::create (i, f, this));

      if (!llfc_.present ())
      {
        this->llfc_.set (r);
        continue;
      }
    }

    // particlePerDimension
    //
    if (n.name () == "particlePerDimension" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< particlePerDimension_type > r (
        particlePerDimension_traits::create (i, f, this));

      if (!particlePerDimension_.present ())
      {
        this->particlePerDimension_.set (r);
        continue;
      }
    }

    // particleVelocity
    //
    if (n.name () == "particleVelocity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< particleVelocity_type > r (
        particleVelocity_traits::create (i, f, this));

      if (!particleVelocity_.present ())
      {
        this->particleVelocity_.set (r);
        continue;
      }
    }

    // h
    //
    if (n.name () == "h" && n.namespace_ ().empty ())
    {
      if (!h_.present ())
      {
        this->h_.set (h_traits::create (i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      if (!mass_.present ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    // generateNumber
    //
    if (n.name () == "generateNumber" && n.namespace_ ().empty ())
    {
      if (!generateNumber_.present ())
      {
        this->generateNumber_.set (generateNumber_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!llfc_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "llfc",
      "");
  }

  if (!particlePerDimension_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "particlePerDimension",
      "");
  }

  if (!particleVelocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "particleVelocity",
      "");
  }

  if (!h_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "h",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }

  if (!generateNumber_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "generateNumber",
      "");
  }
}

Cuboid* Cuboid::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Cuboid (*this, f, c);
}

Cuboid& Cuboid::
operator= (const Cuboid& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->llfc_ = x.llfc_;
    this->particlePerDimension_ = x.particlePerDimension_;
    this->particleVelocity_ = x.particleVelocity_;
    this->h_ = x.h_;
    this->mass_ = x.mass_;
    this->generateNumber_ = x.generateNumber_;
  }

  return *this;
}

Cuboid::
~Cuboid ()
{
}

// simulationConfig
//

simulationConfig::
simulationConfig (const baseName_type& baseName,
                  const writeFrequency_type& writeFrequency,
                  const t_end_type& t_end,
                  const delta_t_type& delta_t,
                  const logLevel_type& logLevel,
                  const inputGenerator_type& inputGenerator,
                  const inputText_type& inputText,
                  const inputPicture_type& inputPicture,
                  const inputXML_type& inputXML)
: ::xml_schema::type (),
  baseName_ (baseName, this),
  writeFrequency_ (writeFrequency, this),
  t_end_ (t_end, this),
  delta_t_ (delta_t, this),
  logLevel_ (logLevel, this),
  inputGenerator_ (inputGenerator, this),
  inputText_ (inputText, this),
  inputPicture_ (inputPicture, this),
  inputXML_ (inputXML, this),
  Cuboid_ (this)
{
}

simulationConfig::
simulationConfig (const simulationConfig& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  baseName_ (x.baseName_, f, this),
  writeFrequency_ (x.writeFrequency_, f, this),
  t_end_ (x.t_end_, f, this),
  delta_t_ (x.delta_t_, f, this),
  logLevel_ (x.logLevel_, f, this),
  inputGenerator_ (x.inputGenerator_, f, this),
  inputText_ (x.inputText_, f, this),
  inputPicture_ (x.inputPicture_, f, this),
  inputXML_ (x.inputXML_, f, this),
  Cuboid_ (x.Cuboid_, f, this)
{
}

simulationConfig::
simulationConfig (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  baseName_ (this),
  writeFrequency_ (this),
  t_end_ (this),
  delta_t_ (this),
  logLevel_ (this),
  inputGenerator_ (this),
  inputText_ (this),
  inputPicture_ (this),
  inputXML_ (this),
  Cuboid_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void simulationConfig::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // baseName
    //
    if (n.name () == "baseName" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< baseName_type > r (
        baseName_traits::create (i, f, this));

      if (!baseName_.present ())
      {
        this->baseName_.set (r);
        continue;
      }
    }

    // writeFrequency
    //
    if (n.name () == "writeFrequency" && n.namespace_ ().empty ())
    {
      if (!writeFrequency_.present ())
      {
        this->writeFrequency_.set (writeFrequency_traits::create (i, f, this));
        continue;
      }
    }

    // t_end
    //
    if (n.name () == "t_end" && n.namespace_ ().empty ())
    {
      if (!t_end_.present ())
      {
        this->t_end_.set (t_end_traits::create (i, f, this));
        continue;
      }
    }

    // delta_t
    //
    if (n.name () == "delta_t" && n.namespace_ ().empty ())
    {
      if (!delta_t_.present ())
      {
        this->delta_t_.set (delta_t_traits::create (i, f, this));
        continue;
      }
    }

    // logLevel
    //
    if (n.name () == "logLevel" && n.namespace_ ().empty ())
    {
      if (!logLevel_.present ())
      {
        this->logLevel_.set (logLevel_traits::create (i, f, this));
        continue;
      }
    }

    // inputGenerator
    //
    if (n.name () == "inputGenerator" && n.namespace_ ().empty ())
    {
      if (!inputGenerator_.present ())
      {
        this->inputGenerator_.set (inputGenerator_traits::create (i, f, this));
        continue;
      }
    }

    // inputText
    //
    if (n.name () == "inputText" && n.namespace_ ().empty ())
    {
      if (!inputText_.present ())
      {
        this->inputText_.set (inputText_traits::create (i, f, this));
        continue;
      }
    }

    // inputPicture
    //
    if (n.name () == "inputPicture" && n.namespace_ ().empty ())
    {
      if (!inputPicture_.present ())
      {
        this->inputPicture_.set (inputPicture_traits::create (i, f, this));
        continue;
      }
    }

    // inputXML
    //
    if (n.name () == "inputXML" && n.namespace_ ().empty ())
    {
      if (!inputXML_.present ())
      {
        this->inputXML_.set (inputXML_traits::create (i, f, this));
        continue;
      }
    }

    // Cuboid
    //
    if (n.name () == "Cuboid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Cuboid_type > r (
        Cuboid_traits::create (i, f, this));

      this->Cuboid_.push_back (r);
      continue;
    }

    break;
  }

  if (!baseName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "baseName",
      "");
  }

  if (!writeFrequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "writeFrequency",
      "");
  }

  if (!t_end_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "t_end",
      "");
  }

  if (!delta_t_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "delta_t",
      "");
  }

  if (!logLevel_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "logLevel",
      "");
  }

  if (!inputGenerator_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "inputGenerator",
      "");
  }

  if (!inputText_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "inputText",
      "");
  }

  if (!inputPicture_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "inputPicture",
      "");
  }

  if (!inputXML_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "inputXML",
      "");
  }
}

simulationConfig* simulationConfig::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class simulationConfig (*this, f, c);
}

simulationConfig& simulationConfig::
operator= (const simulationConfig& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->baseName_ = x.baseName_;
    this->writeFrequency_ = x.writeFrequency_;
    this->t_end_ = x.t_end_;
    this->delta_t_ = x.delta_t_;
    this->logLevel_ = x.logLevel_;
    this->inputGenerator_ = x.inputGenerator_;
    this->inputText_ = x.inputText_;
    this->inputPicture_ = x.inputPicture_;
    this->inputXML_ = x.inputXML_;
    this->Cuboid_ = x.Cuboid_;
  }

  return *this;
}

simulationConfig::
~simulationConfig ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::simulationConfig >
Configuration (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::simulationConfig > (
    ::Configuration (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulationConfig >
Configuration (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::simulationConfig > (
    ::Configuration (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulationConfig >
Configuration (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::simulationConfig > (
    ::Configuration (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulationConfig >
Configuration (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Configuration (isrc, f, p);
}

::std::auto_ptr< ::simulationConfig >
Configuration (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Configuration (isrc, h, f, p);
}

::std::auto_ptr< ::simulationConfig >
Configuration (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Configuration (isrc, h, f, p);
}

::std::auto_ptr< ::simulationConfig >
Configuration (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Configuration (isrc, f, p);
}

::std::auto_ptr< ::simulationConfig >
Configuration (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Configuration (isrc, h, f, p);
}

::std::auto_ptr< ::simulationConfig >
Configuration (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Configuration (isrc, h, f, p);
}

::std::auto_ptr< ::simulationConfig >
Configuration (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::simulationConfig > (
    ::Configuration (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulationConfig >
Configuration (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::simulationConfig > (
    ::Configuration (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulationConfig >
Configuration (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::simulationConfig > (
    ::Configuration (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulationConfig >
Configuration (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::simulationConfig > (
      ::Configuration (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Configuration" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::simulationConfig > r (
      ::xsd::cxx::tree::traits< ::simulationConfig, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Configuration",
    "");
}

::std::auto_ptr< ::simulationConfig >
Configuration (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Configuration" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::simulationConfig > r (
      ::xsd::cxx::tree::traits< ::simulationConfig, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Configuration",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

