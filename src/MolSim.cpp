#include "FileReader.h"
#include "MolSim.h"
#include "outputWriter/XYZWriter.h"
#include "outputWriter/VTKWriter.h"
#include "utils/ArrayUtils.h"
#include "ParticleContainer.h"
#include "ForceV1.h"
#include "spdlog/spdlog.h"
#include "ParticleGenerator.h"

#include <iostream>
#include <fstream>
#include <getopt.h>
#include <vector>
#include <chrono>
#include <nlohmann/json.hpp>
using json = nlohmann::json;

//
constexpr double startTime{0};
double endTime{1000};
double deltaT{0.014};
bool generate = false; // bool which indicates whether the particles are read from a file or generated
int silenceLevel = 1;
bool outputModeVTK = true; // default to VTK

// default values for the particle generator
ParticleGenerator particleGenerator;
std::array<double, 3> llfc{0.0, 0.0, 0.0}; // lower left frontside corner
std::array<unsigned int, 3> particlePerDimension{10, 10, 10};
double h = 0.5;
double mass = 1.0; //<- vllt noch was sinnvolleres hierhin
std::array<double, 3> particleVelocity = {1.0, 1.0, 1.0};

std::vector<Particle> particles;
// ParticleContainer particles
ParticleContainer particleContainer{};

// TODO: Implement mode for runtime measurement which disables all I/O
int main(int argc, char *argsv[])
{
    spdlog::info("Erste Nachricht durch den Logger");
    spdlog::info("Hello from MolSim for PSE\n");
    if (argc < 2)
    {
        spdlog::info("Erroneous program call\n");
        printHelp();
        return EXIT_FAILURE;
    }

    option longOpts[] = {
        {"deltaT", required_argument, nullptr, 'd'},
        {"endTime", required_argument, nullptr, 'e'}, // how long the simulation should run
        {"help", no_argument, nullptr, 'h'},          // print the help.txt file to stdout
        // disable I/O with certain levels. 0 -> debug, print all; 1 -> default, no debug; 2 -> disable std::cout and logging; 3 -> don't write output to files
        {"silent", required_argument, nullptr, 's'},
        {nullptr, 0, nullptr, 0}};

    int longOptsIndex = 0;
    // TODO: Extend with the command line arguments for the generator
    int c = getopt_long(argc, argsv, "d:e:hs:x", longOpts, &longOptsIndex);
    while (c != -1)
    {
        switch (c)
        {
        case 'd':
            deltaT = std::stod(optarg);
            break;
        case 'e':
            endTime = std::stod(optarg);
            break;
        case 'h':
            printHelp();
            break;
        case 's':
        {
            int temp = std::stoi(optarg);
            if (temp >= 0 && temp < 3)
            {
                silenceLevel = temp;
            }
            break;
        }
        case 'x':
            outputModeVTK = false;
            break;
        default:
            std::cout << "Error parsing arguments. Maybe you gave one that isn't recognized." << std::endl;
            break;
        }
        c = getopt_long(argc, argsv, "d:e:hs:x", longOpts, &longOptsIndex);
    }

    if (optind >= argc)
    {
        // std::cout << "Input file missing as an argument, aborting" << std::endl;
        spdlog::info("Input file missing as an argument, aborting\n");
        printHelp();
        return EXIT_FAILURE;
    }

    if (!generate)
    {
        FileReader fileReader;
        // ParticleContainer particleContainer;
        fileReader.readFile(particles, argsv[optind]);
        // Initialising the ParticleContainer with particles
        particleContainer.setParticles(particles);
    }
    else
    {
        // Here the particles will be generated by the ParticleGenerator
        particleGenerator.instantiateCuboid(particleContainer, llfc, particlePerDimension, h, mass, particleVelocity, 0);
    }

    particleContainer.setForceCalculator(0);
    /*
     * Mode 0 GravitationalForce
     * Mode 1 LennardJonesForce
     * Mode 2 infinity: restliche Forces
     */
    particleContainer.setDeltaTTwo(deltaT);

    double currentTime = startTime;
    int iteration = 0;
    spdlog::info(outputModeVTK ? "Plotting particles with VTK." : "Plotting particles with XYZ");
    spdlog::info("This might take a while...");

    // Start measuring time
    auto begin = std::chrono::high_resolution_clock::now();

    // for this loop, we assume: current x, current f and current v are known
    while (currentTime < endTime)
    {
        // calculate new x
        particleContainer.calculatePosition();
        // calculate new f
        particleContainer.calculateForces();
        // calculate new v
        particleContainer.calculateVelocity();

        iteration++;
        if (silenceLevel < 3 && iteration % 10 == 0)
        {
            plotParticles(iteration);
            if (silenceLevel < 2)
            {
                spdlog::info("Iteration {} finished.", iteration);
            }
        }
        currentTime += deltaT;
    }

    // Stop measuring time and calculate the elapsed time
    auto end = std::chrono::high_resolution_clock::now();
    int64_t diff = std::chrono::duration_cast<std::chrono::milliseconds>(end - begin).count();

    // std::cout << "Output written, took " << diff << " seconds. Terminating..." << std::endl;

    spdlog::info("Output written, took {} milliseconds. (about {}) Terminating...\n", diff, (iteration > diff ? std::to_string(iteration / diff) + " iter/ms" : std::to_string(diff / iteration) + " ms/iter"));
    return 0;
}

void plotParticles(int iteration)
{

    if (outputModeVTK)
    {
        std::string outName("../output/MD_vtk");
        outputWriter::VTKWriter writer;
        writer.initializeOutput(particleContainer.getParticles()->size());
        for (auto &p : *particleContainer.getParticles())
        {
            writer.plotParticle(p);
        }
        writer.writeFile(outName, iteration);
    }
    else
    {
        std::string outName("../output/MD_xyz");
        outputWriter::XYZWriter writer;
        writer.plotParticles(*particleContainer.getParticles(), outName, iteration);
    }
}

void printHelp()
{
    std::ifstream file("../help.txt");

    if (file.is_open())
    {
        std::cout << file.rdbuf();
    }
}
